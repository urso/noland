from typing import List, Optional, Union, Dict, Any, Literal
from pydantic import BaseModel, Field
import base64
from llama_index.core.base.llms.types import TextBlock, ImageBlock, AudioBlock
from llama_index.core.llms import ChatMessage


# Content Parts
class ContentPart(BaseModel):
    """Base class for message content parts"""
    type: str
    
    def to_block(self):
        raise NotImplementedError("Subclasses must implement this method")
    
    def content_str(self) -> str:
        raise NotImplementedError("Subclasses must implement this method")

class TextPart(ContentPart):
    """
    Represents a text content part of a message.
    
    This matches the TextPart interface in Vercel AI SDK:
    ```typescript
    interface TextPart {
      type: 'text';
      text: string;
    }
    ```
    """
    type: Literal["text"] = "text"
    text: str
    
    def to_block(self) -> TextBlock:
        return TextBlock(text=self.text)
    
    def content_str(self) -> str:
        return self.text
    

class ImagePart(ContentPart):
    """
    Represents an image part in a user message.
    
    This matches the ImagePart interface in Vercel AI SDK:
    ```typescript
    interface ImagePart {
      type: 'image';
      image: DataContent | URL;
      mimeType?: string;
    }
    ```
    """
    type: Literal["image"] = "image"
    image: str  # URL or base64 encoded string
    mimeType: Optional[str] = None
    
    def to_block(self) -> ImageBlock:
        if self.image.startswith("data:"):
            return ImageBlock(image=base64.b64decode(self.image), mimeType=self.mimeType)
        else:
            return ImageBlock(url=self.image, mimeType=self.mimeType)

    @classmethod
    def from_block(cls, block: ImageBlock) -> "ImagePart":
        if block.image:
            return cls(image=base64.b64encode(block.image).decode('utf-8'), mimeType=block.mimeType)
        else:
            return cls(url=block.url, mimeType=block.mimeType)
        
    def content_str(self) -> str:
        return self.image

class FilePart(ContentPart):
    """
    Represents a file part in a user message.
    
    This matches the FilePart interface in Vercel AI SDK:
    ```typescript
    interface FilePart {
      type: 'file';
      data: DataContent | URL;
      mimeType: string;
    }
    ```
    """
    type: Literal["file"] = "file"
    data: str  # URL or base64 encoded string
    mimeType: str

    def to_block(self) -> TextBlock | AudioBlock:
        if self.data.startswith("data:"):
            if self.mimeType and self.mimeType.startswith("text/"):
                return TextBlock(text=self.data)
            else:
                return AudioBlock(audio=base64.b64decode(self.data), mimeType=self.mimeType)
        else:
            return AudioBlock(url=self.data, mimeType=self.mimeType)
        
    def content_str(self) -> str:
        return self.data

class ToolCallPart(ContentPart):
    """
    Represents a tool call content part, typically generated by the AI model.
    
    This matches the ToolCallPart interface in Vercel AI SDK:
    ```typescript
    interface ToolCallPart {
      type: 'tool-call';
      toolCallId: string;
      toolName: string;
      args: unknown;
    }
    ```
    """
    type: Literal["tool-call"] = "tool-call"
    toolCallId: str
    toolName: str
    args: Dict[str, Any]

    def to_block(self) -> TextBlock:
        # jsonified tool call
        return TextBlock(text=self.content_str())
    
    def content_str(self) -> str:
        return json.dumps({
            "tool_call": {
                "id": self.toolCallId,
                "name": self.toolName,
                "args": self.args
            }
        })

class ToolResultPart(ContentPart):
    """
    Represents the result of a tool call in a tool message.
    
    This matches the ToolResultPart interface in Vercel AI SDK:
    ```typescript
    interface ToolResultPart {
      type: 'tool-result';
      toolCallId: string;
      toolName: string;
      result: unknown;
      isError?: boolean;
    }
    ```
    """
    type: Literal["tool-result"] = "tool-result"
    toolCallId: str
    toolName: str
    result: Any
    isError: Optional[bool] = None
    
    def to_block(self) -> TextBlock:
        return TextBlock(text=self.content_str())
    
    def content_str(self) -> str:
        doc = {
            "tool_result": {
                "id": self.toolCallId,
                "name": self.toolName,
                "result": self.result
            }
        }
        if self.isError:
            doc["tool_result"]["is_error"] = self.isError
        return TextBlock(text=json.dumps(doc))

# Message Types
class CoreMessage(BaseModel):
    """Base class for all message types"""
    role: str

class CoreSystemMessage(CoreMessage):
    """
    A system message that can contain system information.
    
    This matches the CoreSystemMessage type in Vercel AI SDK:
    ```typescript
    type CoreSystemMessage = {
      role: 'system';
      content: string;
    };
    ```
    """
    role: Literal["system"] = "system"
    content: str
    
    def to_chatmessage(self) -> ChatMessage:
        return ChatMessage(role="system", content=self.content)
    
    def content_str(self) -> str:
        return self.content

class CoreUserMessage(CoreMessage):
    """
    A user message that can contain text or a combination of text, images, and files.
    
    This matches the CoreUserMessage type in Vercel AI SDK:
    ```typescript
    type CoreUserMessage = {
      role: 'user';
      content: string | Array<TextPart | ImagePart | FilePart>;
    };
    ```
    """
    role: Literal["user"] = "user"
    # For Pydantic v1 compatibility, we need to simplify the Union types
    content: Union[str, List[ContentPart]]
    
    def to_chatmessage(self) -> ChatMessage:
        if isinstance(self.content, str):
            return ChatMessage(role="user", content=self.content)
        elif isinstance(self.content, list):
            return ChatMessage(role="user", content=[part.to_block() for part in self.content])
        else:
            raise ValueError("Invalid content type")
        
    def content_str(self) -> str:
        if isinstance(self.content, str):
            return self.content
        elif isinstance(self.content, list):
            return " ".join([part.content_str() for part in self.content])
        else:
            raise ValueError("Invalid content type")

class CoreAssistantMessage(CoreMessage):
    """
    An assistant message that can contain text, tool calls, or a combination of both.
    
    This matches the CoreAssistantMessage type in Vercel AI SDK:
    ```typescript
    type CoreAssistantMessage = {
      role: 'assistant';
      content: string | Array<TextPart | ToolCallPart>;
    };
    ```
    """
    role: Literal["assistant"] = "assistant"
    # For Pydantic v1 compatibility, we need to simplify the Union types
    content: Union[str, List[ContentPart]]

    def to_chatmessage(self) -> ChatMessage:
        if isinstance(self.content, str):
            return ChatMessage(role="assistant", content=self.content)
        else:
            return ChatMessage(role="assistant", content=[part.to_block() for part in self.content])
    
    def content_str(self) -> str:
        if isinstance(self.content, str):
            return self.content
        elif isinstance(self.content, list):
            return " ".join([part.content_str() for part in self.content])
        else:
            raise ValueError("Invalid content type")

class CoreToolMessage(CoreMessage):
    """
    A tool message that contains the result of one or more tool calls.
    
    This matches the CoreToolMessage type in Vercel AI SDK:
    ```typescript
    type CoreToolMessage = {
      role: 'tool';
      content: Array<ToolResultPart>;
    };
    ```
    """
    role: Literal["tool"] = "tool"
    # For Pydantic v1 compatibility, we need to simplify the type
    content: List[ToolResultPart]
    
    def to_chatmessage(self) -> ChatMessage:
        return ChatMessage(role="tool", content=[part.to_block() for part in self.content])
    
    def content_str(self) -> str:
        return " ".join([part.content_str() for part in self.content])

# Define the Message type as a union of all Core message types
# This is a type annotation, not a class
Message = Union[CoreSystemMessage, CoreUserMessage, CoreAssistantMessage, CoreToolMessage]

# Simple Message class for backward compatibility
class SimpleMessage(BaseModel):
    """
    A simple message class for backward compatibility.
    
    This is a simplified version of the Message type that only contains
    role and content as strings, which is compatible with most LLM APIs.
    """
    role: str
    content: str
    
    @classmethod
    def from_core_message(cls, message: Message) -> "SimpleMessage":
        """Convert a CoreMessage to a SimpleMessage"""
        if isinstance(message.content, str):
            return cls(role=message.role, content=message.content)
        elif isinstance(message.content, list) and message.content:
            # For multi-part content, convert all content blocks to their string representations
            content_strs = []
            for part in message.content:
                if hasattr(part, "type"):
                    if part.type == "text" and hasattr(part, "text"):
                        content_strs.append(part.text)
                    elif part.type == "image" and hasattr(part, "image"):
                        content_strs.append(f"[Image: {part.image}]")
                    elif part.type == "file" and hasattr(part, "data"):
                        content_strs.append(f"[File: {part.data}]")
                    elif part.type == "tool-call" and hasattr(part, "toolName"):
                        content_strs.append(f"[Tool Call: {part.toolName}]")
                    elif part.type == "tool-result" and hasattr(part, "result"):
                        content_strs.append(f"[Tool Result: {part.result}]")
            return cls(role=message.role, content=" ".join(content_strs) if content_strs else "")
        return cls(role=message.role, content="")